#!/usr/bin/env node

const fs = require('fs')
const path = require('path')
const cwd = process.cwd()
const cfg = require(path.resolve(cwd, 'hooks/config.js'))
const isForce = process.argv[2] === 'force'
const prevHead = process.argv[2]
const newHead = process.argv[3]
const isBranchCheckout = process.argv[4] === '1'
const isNewBranch = isBranchCheckout && (prevHead === newHead)

if (isNewBranch || isForce) {
  const action = isForce ? 'Force' : 'New branch created:'
  console.log(`${action} syncing Postman collection..`)

  const { postmanApiKey, collectionFile } = cfg
  const collectionJson = JSON.parse(fs.readFileSync(path.resolve(cwd, collectionFile)).toString())
  const collection = JSON.stringify({ collection: collectionJson })

  createCollection(collection, postmanApiKey)
}

function createCollection (collection, postmanApiKey) {
  const https = require('https')

  const options = {
    hostname: 'api.getpostman.com',
    port: 443,
    path: '/collections',
    method: 'POST',
    headers: {
      'X-Api-Key': postmanApiKey,
      'Content-Type': 'application/json',
      'Content-Length': collection.length
    }
  }

  const req = https.request(options, (res) => {
    res.on('data', (d) => {
      cfg.uid = JSON.parse(d).collection.uid
      fs.writeFileSync(path.resolve(cwd, 'hooks/config.js'), `module.exports = ${JSON.stringify(cfg)}`)
      console.log('Collection synced in personal workspace!')
    })
  })

  req.on('error', (error) => {
    console.error(error)
  })

  req.write(collection)
  req.end()
}
